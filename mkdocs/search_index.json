{
    "docs": [
        {
            "location": "/",
            "text": "Tisp\n\n\nThe \"Time is Space\" programming language\n\n\nTisp is a functional programming language with implicit parallelism and\nconcurrency.\nIt aims to be simple, canonical, and practical.\n\n\nTL;DR\n\n\n\n\nTisp evaluates every output of a program (such as printing a string and\n  sending an HTTP response to a client) parallelly and concurrently by default\n  leaving synchronization optional.\n\n\nTisp keeps the other part of a program pure (i.e. without any output).\n\n\nTherefore, every program in Tisp can run parallelly and concurrently with\n  nothing special!\n\n\n\n\nBackground\n\n\nExisting programming languages are synchronous by default.\nFor example, when you write code in C like the below, the statements are run\nsequentially one by one even if they can be run in parallel.\n\n\nsend(http_response);\nsend(another_http_response);\n\n\n\n\nTherefore, many libraries, frameworks, and language features for parallel,\nconcurrent, and asynchronous programming have emerged in recent years.\n\n\nTisp takes the different way to deal with this problem.\nIt lets you write programs which are asynchronous, concurrent, and parallel\ninherently.\n\n\nHow?\n\n\n\n\nWarning: This is an immature concept.\nPlease post any feedback to improve or fix it in\n\nthe Google group\n.\n\n\n\n\nTisp assumes that \ntime is space\n.\nIf \ntime is space\n, everything is constant because nothing changes over time.\nThis fact lets us write programs as functions which map their inputs to\noutputs.\n\n\nLet's think about a program which takes input data \ninput[t]\n and outputs\nsomething \noutput[t]\n at every time step \nt\n.\nThen, every \noutput[t]\n should be calculated from all inputs in the past.\n\n\ninput[0], input[1], ..., input[t-1] -> output[t]\n\n\n\n\nThis is true for any \nt\n.\nTherefore, a program can be represented as a function which maps its inputs to\noutputs.\n\n\nprogram : input[0], ..., input[T] -> output[0], ..., output[T]\n\n\n\n\nwhere \nT\n is infinite generally.\nThen, we can extract great parallelism of a program because the program as a\nfunction represents just data dependency.\n\n\nTisp evaluates the outputs concurrently and parallelly.\nProgrammers must specify their causality using the \nseq\n primitive function if\nnecessary.\n\n\nReferences\n\n\n\n\nHaskell Language\n\n\nGlasgow Parallel Haskell",
            "title": "Home"
        },
        {
            "location": "/#tisp",
            "text": "The \"Time is Space\" programming language  Tisp is a functional programming language with implicit parallelism and\nconcurrency.\nIt aims to be simple, canonical, and practical.",
            "title": "Tisp"
        },
        {
            "location": "/#tldr",
            "text": "Tisp evaluates every output of a program (such as printing a string and\n  sending an HTTP response to a client) parallelly and concurrently by default\n  leaving synchronization optional.  Tisp keeps the other part of a program pure (i.e. without any output).  Therefore, every program in Tisp can run parallelly and concurrently with\n  nothing special!",
            "title": "TL;DR"
        },
        {
            "location": "/#background",
            "text": "Existing programming languages are synchronous by default.\nFor example, when you write code in C like the below, the statements are run\nsequentially one by one even if they can be run in parallel.  send(http_response);\nsend(another_http_response);  Therefore, many libraries, frameworks, and language features for parallel,\nconcurrent, and asynchronous programming have emerged in recent years.  Tisp takes the different way to deal with this problem.\nIt lets you write programs which are asynchronous, concurrent, and parallel\ninherently.",
            "title": "Background"
        },
        {
            "location": "/#how",
            "text": "Warning: This is an immature concept.\nPlease post any feedback to improve or fix it in the Google group .   Tisp assumes that  time is space .\nIf  time is space , everything is constant because nothing changes over time.\nThis fact lets us write programs as functions which map their inputs to\noutputs.  Let's think about a program which takes input data  input[t]  and outputs\nsomething  output[t]  at every time step  t .\nThen, every  output[t]  should be calculated from all inputs in the past.  input[0], input[1], ..., input[t-1] -> output[t]  This is true for any  t .\nTherefore, a program can be represented as a function which maps its inputs to\noutputs.  program : input[0], ..., input[T] -> output[0], ..., output[T]  where  T  is infinite generally.\nThen, we can extract great parallelism of a program because the program as a\nfunction represents just data dependency.  Tisp evaluates the outputs concurrently and parallelly.\nProgrammers must specify their causality using the  seq  primitive function if\nnecessary.",
            "title": "How?"
        },
        {
            "location": "/#references",
            "text": "Haskell Language  Glasgow Parallel Haskell",
            "title": "References"
        },
        {
            "location": "/language_specification/",
            "text": "Language Specification (by examples)\n\n\n\n\nWarning: Too many parentheses ahead!\n\n\n\n\nBasics\n\n\nSimple function calls\n\n\nA simple function call is represented by a function and some positional\narguments.\n\n\n(function argument)\n(function argument1 argument2)\n(function argument1 argument2 argument3 argument4 argument5)\n\n\n\n\nData types\n\n\nThere are number, string, bool, nil, list, dictionary, and function types.\n\n\nNumber\n\n\n123\n1.1\n010\n0x10\n-123\n(+ 1 2 3)\n(- 3 2 1)\n(* 1 2 3)\n(/ 1 2)\n(** 2 3)\n(mod 42 5)\n\n\n\n\nString\n\n\n\"Foo bar baz.\"\n\n\n\n\nBool\n\n\ntrue\nfalse\n\n\n\n\nNil\n\n\nnil\n\n\n\n\nList\n\n\n[1 2 3]\n\n\n\n\nDictionary\n\n\n{\"key1\" 123 \"key2\" 456}\n\n\n\n\nFunction calls\n\n\nIn addition to positional arguments, Tisp supports keyword arguments,\npositional rest arguments and keyword rest arguments.\n\n\n(function positionalArgument)\n(function positionalArgument1 positionalArgument2)\n(function ..expandedList)\n(function . keywordArgument itsValue)\n(function . keywordArgument1 itsValue1 keywordArgument2 itsValue2)\n(function . ..expandedDictionary)\n(function positionalArgument1 positionalArgument2 ..expandedList1\n          positionalArgument3 ..expandedList2\n          .\n          keywordArgument1 itsValue1\n          keywordArgument2 itsValue2\n          ..expandedDictionary1\n          ..expandedDictionary2)\n\n\n\n\nSpecial forms\n\n\nFunction or variable definition \nlet\n\n\n(let myVariable 123)\n(let (myFunc x) (+ x 42))\n(let (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))\n\n\n\n\nMutually-recursive functions \nmr\n\n\n(mr\n  (let (even? n)\n       (if (= n 0) true (odd? (- n 1))))\n  (let (odd? n)\n       (if (= n 0) false (even? (- n 1)))))\n\n\n\n\nMacro definition \nmacro\n\n\nTBD\n\n\nBuilt-in functions\n\n\nTBD",
            "title": "Language Specification"
        },
        {
            "location": "/language_specification/#language-specification-by-examples",
            "text": "Warning: Too many parentheses ahead!",
            "title": "Language Specification (by examples)"
        },
        {
            "location": "/language_specification/#basics",
            "text": "",
            "title": "Basics"
        },
        {
            "location": "/language_specification/#simple-function-calls",
            "text": "A simple function call is represented by a function and some positional\narguments.  (function argument)\n(function argument1 argument2)\n(function argument1 argument2 argument3 argument4 argument5)",
            "title": "Simple function calls"
        },
        {
            "location": "/language_specification/#data-types",
            "text": "There are number, string, bool, nil, list, dictionary, and function types.",
            "title": "Data types"
        },
        {
            "location": "/language_specification/#number",
            "text": "123\n1.1\n010\n0x10\n-123\n(+ 1 2 3)\n(- 3 2 1)\n(* 1 2 3)\n(/ 1 2)\n(** 2 3)\n(mod 42 5)",
            "title": "Number"
        },
        {
            "location": "/language_specification/#string",
            "text": "\"Foo bar baz.\"",
            "title": "String"
        },
        {
            "location": "/language_specification/#bool",
            "text": "true\nfalse",
            "title": "Bool"
        },
        {
            "location": "/language_specification/#nil",
            "text": "nil",
            "title": "Nil"
        },
        {
            "location": "/language_specification/#list",
            "text": "[1 2 3]",
            "title": "List"
        },
        {
            "location": "/language_specification/#dictionary",
            "text": "{\"key1\" 123 \"key2\" 456}",
            "title": "Dictionary"
        },
        {
            "location": "/language_specification/#function-calls",
            "text": "In addition to positional arguments, Tisp supports keyword arguments,\npositional rest arguments and keyword rest arguments.  (function positionalArgument)\n(function positionalArgument1 positionalArgument2)\n(function ..expandedList)\n(function . keywordArgument itsValue)\n(function . keywordArgument1 itsValue1 keywordArgument2 itsValue2)\n(function . ..expandedDictionary)\n(function positionalArgument1 positionalArgument2 ..expandedList1\n          positionalArgument3 ..expandedList2\n          .\n          keywordArgument1 itsValue1\n          keywordArgument2 itsValue2\n          ..expandedDictionary1\n          ..expandedDictionary2)",
            "title": "Function calls"
        },
        {
            "location": "/language_specification/#special-forms",
            "text": "",
            "title": "Special forms"
        },
        {
            "location": "/language_specification/#function-or-variable-definition-let",
            "text": "(let myVariable 123)\n(let (myFunc x) (+ x 42))\n(let (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))",
            "title": "Function or variable definition let"
        },
        {
            "location": "/language_specification/#mutually-recursive-functions-mr",
            "text": "(mr\n  (let (even? n)\n       (if (= n 0) true (odd? (- n 1))))\n  (let (odd? n)\n       (if (= n 0) false (even? (- n 1)))))",
            "title": "Mutually-recursive functions mr"
        },
        {
            "location": "/language_specification/#macro-definition-macro",
            "text": "TBD",
            "title": "Macro definition macro"
        },
        {
            "location": "/language_specification/#built-in-functions",
            "text": "TBD",
            "title": "Built-in functions"
        },
        {
            "location": "/for_developers/",
            "text": "For Developers\n\n\nPreparing environment\n\n\nInstall Go 1.8+ and \nrake\n, the task runner in Ruby.\nThen, install Tisp's dependnecies.\n\n\nrake install_deps\n\n\n\n\nTesting\n\n\n\n\nrake unit_test\n runs unit tests.\n\n\nrake command_test\n runs command tests.\n\n\nrake test\n runs both.\n\n\n\n\nOther utility tasks\n\n\n\n\nrake format\n formats all files.\n\n\nrake lint\n lints all files.\n\n\nrake clean\n cleans up the repository directory.\n\n\n\n\nFor more information, see \nrakefile.rb\n.",
            "title": "For Developers"
        },
        {
            "location": "/for_developers/#for-developers",
            "text": "",
            "title": "For Developers"
        },
        {
            "location": "/for_developers/#preparing-environment",
            "text": "Install Go 1.8+ and  rake , the task runner in Ruby.\nThen, install Tisp's dependnecies.  rake install_deps",
            "title": "Preparing environment"
        },
        {
            "location": "/for_developers/#testing",
            "text": "rake unit_test  runs unit tests.  rake command_test  runs command tests.  rake test  runs both.",
            "title": "Testing"
        },
        {
            "location": "/for_developers/#other-utility-tasks",
            "text": "rake format  formats all files.  rake lint  lints all files.  rake clean  cleans up the repository directory.   For more information, see  rakefile.rb .",
            "title": "Other utility tasks"
        }
    ]
}